import AsyncStorage from '@react-native-async-storage/async-storage';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import { NavigationContainer, NavigationContainerRef } from '@react-navigation/native';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import * as Notifications from 'expo-notifications';
import React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { AppState } from 'react-native';
import {
  getNewMatchCount,
  getUserProfile, // í”„ë¡œí•„ ì¡°íšŒ í•¨ìˆ˜ ì„í¬íŠ¸
  saveUserLocation,
  savePushToken,
  getMyChatRooms,
} from './service/mockApi';

// í™”ë©´ ì»´í¬ë„ŒíŠ¸ë“¤
import ChatDetailScreen from './screens/ChatDetailScreen';
import ChatScreen from './screens/ChatScreen';
import LoginScreen from './screens/LoginScreen';
import LostScreen from './screens/LostScreen';
import MatchScreen from './screens/MatchScreen';
import MyPageScreen from './screens/MypageScreen';
import NotificationsScreen from './screens/NotificationsScreen';
import PostDetailScreen from './screens/PostDetailScreen';
import SignUpScreen from './screens/SignUpScreen';
import WritePostScreen from './screens/WritePostScreen';
import PostDetailGuestScreen from './screens/PostDetailGuestScreen';
import ReportScreen from './screens/ReportScreen';

// ìœ í‹¸ë¦¬í‹° ë° íƒ€ì…
import ChatOffIcon from './assets/images/chatoff.svg';
import ChatOnIcon from './assets/images/chaton.svg';
import HomeOffIcon from './assets/images/homeoff.svg';
import HomeOnIcon from './assets/images/homeon.svg';
import MatchOffIcon from './assets/images/matchoff.svg';
import MatchOnIcon from './assets/images/matchon.svg';
import MyPageOffIcon from './assets/images/mypageoff.svg';
import MyPageOnIcon from './assets/images/mypageon.svg';
import {
  AuthContextType,
  AuthResult, // AuthResult ì„í¬íŠ¸
  AuthStackParamList,
  RootStackParamList,
  RootTabParamList,
  UserProfile,
  PushNotificationData,
} from './types';
import { setupPushNotifications } from './utils/pushNotifications';
import { startLocationUpdates } from './utils/location';

const Tab = createBottomTabNavigator<RootTabParamList>();
const MainStack = createNativeStackNavigator<RootStackParamList>();
const AuthStack = createNativeStackNavigator<AuthStackParamList>();
export const AuthContext = React.createContext<AuthContextType & { userMemberId: number | null }>({
  isLoggedIn: false,
  userMemberName: null,
  userProfile: null,
  userMemberId: null, // AuthContextTypeì— ì¶”ê°€ëœ userMemberIdë¥¼ ê¸°ë³¸ê°’ìœ¼ë¡œ ì„¤ì •
  signIn: async () => {},
  signOut: () => {},
  fetchUserProfile: async () => {},
});
export const navigationRef = React.createRef<NavigationContainerRef<any>>();

// ğŸš¨ ìˆ˜ì • 1: NotificationBehavior íƒ€ì… ìš”êµ¬ì‚¬í•­ì„ ì¶©ì¡±ì‹œí‚¤ê¸° ìœ„í•´ shouldShowBannerì™€ shouldListë¥¼ ì¶”ê°€
Notifications.setNotificationHandler({
  handleNotification: async (notification: Notifications.Notification) => ({
    shouldShowAlert: true,
    shouldPlaySound: false,
    shouldSetBadge: false,
    // ğŸš¨ í•„ìˆ˜ ì†ì„±ì¸ shouldShowBannerì™€ shouldShowListë¥¼ ëª¨ë‘ ì¶”ê°€í•©ë‹ˆë‹¤.
    shouldShowBanner: true, 
    shouldShowList: true, 
  }),
});

function RootTabNavigator() {
  const [matchCount, setMatchCount] = useState(0);
  const [unreadChatCount, setUnreadChatCount] = useState(0);
  const authContext = React.useContext(AuthContext);

  // userMemberName ëŒ€ì‹  userMemberIdë¥¼ ì‚¬ìš©í•˜ì—¬ API í˜¸ì¶œ ì¡°ê±´ í™•ì¸
  const { isLoggedIn, userMemberId } = authContext;

  const fetchBadgeCounts = async () => {
    if (!isLoggedIn || !userMemberId) return;
    try {
      const newMatches = await getNewMatchCount();
      setMatchCount(newMatches);
      const chatRooms = await getMyChatRooms();
      const totalUnread = chatRooms.reduce((sum, room) => sum + (room.unreadCount || 0), 0);
      setUnreadChatCount(totalUnread);
    } catch (error) {
      console.error("Failed to fetch badge counts:", error);
    }
  };

  useEffect(() => {
    if (isLoggedIn) {
      fetchBadgeCounts();
    }
  }, [isLoggedIn, userMemberId]); // userMemberName ëŒ€ì‹  userMemberIdë¥¼ ì˜ì¡´ì„± ë°°ì—´ì— ì¶”ê°€

  return (
    <Tab.Navigator 
      screenOptions={{
        headerShown: false, 
        tabBarActiveTintColor: '#333', 
        tabBarStyle: { 
          height: 100, 
          paddingBottom: 10,
          backgroundColor: 'transparent',
          borderTopWidth: 1,
          borderTopColor: '#f0f0f0',
          elevation: 0,
        } 
      }}
    >
      <Tab.Screen 
        name="Lost" 
        component={LostScreen} 
        options={{
          title: 'í™ˆ',
          tabBarIcon: ({ focused, color }) => 
            focused ? <HomeOnIcon color={color} /> : <HomeOffIcon color={color} />
        }} 
      />
      <Tab.Screen 
        name="Match" 
        component={MatchScreen} 
        options={{
          title: 'ë§¤ì¹­',
          tabBarIcon: ({ focused, color }) => 
            focused ? <MatchOnIcon color={color} /> : <MatchOffIcon color={color} />,
          tabBarBadge: matchCount > 0 ? matchCount : undefined
        }} 
      />
      <Tab.Screen 
        name="Chat" 
        component={ChatScreen} 
        options={{
          title: 'ì±„íŒ…',
          tabBarIcon: ({ focused, color }) => 
            focused ? <ChatOnIcon color={color} /> : <ChatOffIcon color={color} />,
          tabBarBadge: unreadChatCount > 0 ? unreadChatCount : undefined
        }} 
      />
      <Tab.Screen 
        name="MyPage" 
        component={MyPageScreen} 
        options={{
          title: 'ë§ˆì´í˜ì´ì§€',
          tabBarIcon: ({ focused, color }) => 
            focused ? <MyPageOnIcon color={color} /> : <MyPageOffIcon color={color} />
        }} 
      />
    </Tab.Navigator>
  );
}

function AuthStackScreen() {
  return (
    <AuthStack.Navigator screenOptions={{ headerShown: false }}>
      <AuthStack.Screen name="Lost" component={LostScreen} />
      <AuthStack.Screen name="PostDetail" component={PostDetailGuestScreen} />
      <AuthStack.Screen name="LoginScreen" component={LoginScreen} />
      <AuthStack.Screen name="SignUpScreen" component={SignUpScreen} />
    </AuthStack.Navigator>
  );
}

function MainAppStackScreen() {
  return (
    <MainStack.Navigator screenOptions={{ headerShown: false }}>
      <MainStack.Screen name="RootTab" component={RootTabNavigator} />
      <MainStack.Screen name="PostDetail" component={PostDetailScreen} />
      <MainStack.Screen name="WritePostScreen" component={WritePostScreen} />
      <MainStack.Screen name="ChatDetail" component={ChatDetailScreen} />
      <MainStack.Screen name="NotificationsScreen" component={NotificationsScreen} />
      <MainStack.Screen name="Report" component={ReportScreen} />
    </MainStack.Navigator>
  );
}

export default function App() {
  const [isLoggedIn, setIsLoggedIn] = useState(false);
  const [userMemberName, setUserMemberName] = useState<string | null>(null);
  const [userProfile, setUserProfile] = useState<UserProfile | null>(null);
  // ğŸš¨ ì¶”ê°€: userMemberId ìƒíƒœ ê´€ë¦¬ (userProfile.memberIdê°€ ìˆì§€ë§Œ ëª…ì‹œì ìœ¼ë¡œ ê´€ë¦¬)
  const [userMemberId, setUserMemberId] = useState<number | null>(null); 
  const [isLoading, setIsLoading] = useState(true);

  const appState = useRef(AppState.currentState);
  const locationIntervalRef = useRef<NodeJS.Timeout | null>(null);
  const notificationReceivedListener = useRef<Notifications.Subscription | null>(null);
  const notificationResponseListener = useRef<Notifications.Subscription | null>(null);

  const handleNotification = (data: PushNotificationData) => {
    if (!data) return;
    console.log('ì•Œë¦¼ ë°ì´í„° ì²˜ë¦¬:', data);
    if (data.type === 'MATCH_FOUND' && data.postId) {
      navigationRef.current?.navigate('Match', { postId: data.postId });
    }
    // ë‹¤ë¥¸ ì¢…ë¥˜ì˜ ì•Œë¦¼ì— ëŒ€í•œ ì²˜ë¦¬ ì¶”ê°€ ê°€ëŠ¥
  };

  const startPeriodicLocationUpdates = useCallback(() => {
    if (locationIntervalRef.current) {
      clearInterval(locationIntervalRef.current);
    }
    console.log('ì£¼ê¸°ì  ìœ„ì¹˜ ì—…ë°ì´íŠ¸ ì‹œì‘.');
    startLocationUpdates(); // ì¦‰ì‹œ ì‹¤í–‰
    locationIntervalRef.current = setInterval(startLocationUpdates, 5 * 60 * 1000); // 5ë¶„ë§ˆë‹¤
  }, []);

  const stopPeriodicLocationUpdates = useCallback(() => {
    if (locationIntervalRef.current) {
      clearInterval(locationIntervalRef.current);
      locationIntervalRef.current = null;
      console.log('ì£¼ê¸°ì  ìœ„ì¹˜ ì—…ë°ì´íŠ¸ ì¤‘ì§€.');
    }
  }, []);

  // ğŸš¨ 4. `signOut` í•¨ìˆ˜ ìˆ˜ì •: AsyncStorageì—ì„œ `userMemberId` ì œê±°
  const signOut = useCallback(async () => {
    setIsLoggedIn(false);
    setUserMemberName(null);
    setUserProfile(null);
    setUserMemberId(null); // ìƒíƒœì—ì„œë„ ì œê±°
    stopPeriodicLocationUpdates(); // ë¡œê·¸ì•„ì›ƒ ì‹œ ìœ„ì¹˜ ì—…ë°ì´íŠ¸ ì¤‘ì§€
    try {
      await AsyncStorage.removeItem('accessToken');
      await AsyncStorage.removeItem('userMemberName');
      await AsyncStorage.removeItem('userMemberId');
      // AuthResultì— refreshTokenì´ í¬í•¨ë˜ë¯€ë¡œ, í•„ìš”í•˜ë‹¤ë©´ refreshTokenë„ ì œê±°
      await AsyncStorage.removeItem('refreshToken'); 
    } catch (error) {
      console.error('ë¡œê·¸ì•„ì›ƒ ì‹¤íŒ¨', error);
    }
  }, [stopPeriodicLocationUpdates]);

  const fetchUserProfile = useCallback(async () => {
    try {
      const profile = await getUserProfile();
      console.log('DEBUG: App.tsx - Profile fetched:', profile);
      setUserProfile(profile);
      // fetchUserProfileì—ì„œ ë°›ì•„ì˜¨ userProfileì˜ memberIdë¡œ userMemberId ìƒíƒœ ì—…ë°ì´íŠ¸
      setUserMemberId(profile.memberId); 
      console.log('DEBUG: App.tsx - userProfile state after set:', profile);
    } catch (error) {
      console.error('í”„ë¡œí•„ ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨:', error);
      await signOut();
    }
  }, [signOut]);

  useEffect(() => {
    // ğŸš¨ 3. `bootstrapAsync` í•¨ìˆ˜ ìˆ˜ì •: `userMemberId` ê²€ìƒ‰ ë° `userProfile` êµ¬ì„±
    const bootstrapAsync = async () => {
      try {
        const token = await AsyncStorage.getItem('accessToken');
        const memberName = await AsyncStorage.getItem('userMemberName');
        // ğŸš¨ ë³€ê²½: AsyncStorageì—ì„œ userMemberIdë¥¼ ê²€ìƒ‰
        const memberIdString = await AsyncStorage.getItem('userMemberId'); 
        
        console.log('DEBUG: App.tsx - Retrieved token:', token);
        console.log('DEBUG: App.tsx - Retrieved memberName:', memberName);
        console.log('DEBUG: App.tsx - Retrieved memberIdString:', memberIdString);

        if (token && memberName && memberIdString) {
          const memberId = Number(memberIdString);
          setIsLoggedIn(true);
          setUserMemberName(memberName);
          setUserMemberId(memberId); // ê²€ìƒ‰ëœ memberIdë¡œ ìƒíƒœ ì„¤ì •
          
          // ğŸš¨ ë³€ê²½: ê²€ìƒ‰ëœ userMemberIdë¥¼ ì‚¬ìš©í•˜ì—¬ userProfile ê°ì²´ë¥¼ êµ¬ì„±
          setUserProfile({
            memberId: memberId,
            username: memberName,
            email: '', // ë¡œê·¸ì¸ ì‹œ ì´ë©”ì¼ ì •ë³´ê°€ ì—†ìœ¼ë¯€ë¡œ ë¹ˆ ë¬¸ìì—´ë¡œ ì„¤ì •
          });
        } else {
          // í† í°ì´ë‚˜ memberName, memberId ì¤‘ í•˜ë‚˜ë¼ë„ ì—†ìœ¼ë©´ ë¡œê·¸ì•„ì›ƒ ì²˜ë¦¬
          await signOut();
        }
      } catch (e) {
        console.error('ìë™ ë¡œê·¸ì¸ ì‹¤íŒ¨', e);
        await signOut();
      }
      setIsLoading(false);
    };

    bootstrapAsync();
  }, [signOut]); // signOutì„ ì˜ì¡´ì„± ë°°ì—´ì— ì¶”ê°€

  const authContext = useMemo(() => ({
    isLoggedIn,
    userMemberName,
    userProfile,
    // ğŸš¨ ë³€ê²½: userProfile?.memberId ëŒ€ì‹  userMemberId ìƒíƒœë¥¼ ì‚¬ìš©
    userMemberId: userMemberId, 
    // ğŸš¨ 2. `signIn` í•¨ìˆ˜ ìˆ˜ì •: `authResult.userId`ë¥¼ ì˜ˆìƒí•˜ê³  ì²˜ë¦¬
    signIn: async (authResult: AuthResult) => {
      // AuthResult íƒ€ì…ì— userIdê°€ í¬í•¨ë˜ì–´ ìˆë‹¤ê³  ê°€ì •í•˜ê³  ì‚¬ìš©í•©ë‹ˆë‹¤.
      const { userId, memberName, accessToken, refreshToken } = authResult; 

      setIsLoggedIn(true);
      setUserMemberName(memberName);
      setUserMemberId(userId); // userId ìƒíƒœ ì—…ë°ì´íŠ¸

      try {
        await AsyncStorage.setItem('userMemberName', memberName);
        await AsyncStorage.setItem('accessToken', accessToken); // accessToken ì €ì¥
        // ğŸš¨ ë³€ê²½: authResult.userIdë¥¼ userMemberIdë¡œ ì €ì¥
        await AsyncStorage.setItem('userMemberId', userId.toString()); 
        // refreshToken ì €ì¥ (AuthResultì— í¬í•¨ë˜ì—ˆë‹¤ê³  ê°€ì •)
        await AsyncStorage.setItem('refreshToken', refreshToken);

        // ğŸš¨ ë³€ê²½: authResult.userIdë¥¼ ì‚¬ìš©í•˜ì—¬ userProfile ê°ì²´ë¥¼ êµ¬ì„±
        setUserProfile({
          memberId: userId,
          username: memberName,
          email: '', // ë¡œê·¸ì¸ ì‹œ ì´ë©”ì¼ ì •ë³´ê°€ ì—†ìœ¼ë¯€ë¡œ ë¹ˆ ë¬¸ìì—´ë¡œ ì„¤ì •
        });
      } catch (error) {
        console.error('ë¡œê·¸ì¸ í›„ ì²˜ë¦¬ ì‹¤íŒ¨', error);
      }
    },
    signOut,
    fetchUserProfile,
  }), [isLoggedIn, userMemberName, userProfile, userMemberId, signOut, fetchUserProfile]); // userMemberIdë¥¼ ì˜ì¡´ì„± ë°°ì—´ì— ì¶”ê°€

  useEffect(() => {
    const handleAppStateChange = (nextAppState: AppState['currentState']) => {
      const wasInBackground = appState.current.match(/inactive|background/);
      const isActive = nextAppState === 'active';

      if (isLoggedIn) {
        if (wasInBackground && isActive) {
          console.log('ì•±ì´ í¬ê·¸ë¼ìš´ë“œë¡œ ì „í™˜ë˜ì—ˆìŠµë‹ˆë‹¤.');
          setupPushNotifications();
          startPeriodicLocationUpdates();
        } else if (!isActive) {
          console.log('ì•±ì´ ë°±ê·¸ë¼ìš´ë“œë¡œ ì „í™˜ë˜ì—ˆìŠµë‹ˆë‹¤.');
          stopPeriodicLocationUpdates();
        }
      }
      appState.current = nextAppState;
    };

    const subscription = AppState.addEventListener('change', handleAppStateChange);

    if (isLoggedIn) {
      console.log('ë¡œê·¸ì¸ ìƒíƒœ: í‘¸ì‹œ ì•Œë¦¼ ë° ìœ„ì¹˜ ì—…ë°ì´íŠ¸ ì„¤ì •');
      setupPushNotifications();
      startPeriodicLocationUpdates();
    } else {
      stopPeriodicLocationUpdates();
    }

    notificationReceivedListener.current = Notifications.addNotificationReceivedListener(notification => {
      console.log('ìƒˆ ì•Œë¦¼ ë„ì°©:', notification);
    });

    notificationResponseListener.current = Notifications.addNotificationResponseReceivedListener(response => {
      // ğŸš¨ ìˆ˜ì • 2: íƒ€ì… ë‹¨ì–¸ ë°©ì‹ì„ as unknown as PushNotificationDataë¡œ ë³€ê²½í•˜ì—¬ ì˜¤ë¥˜ í•´ê²°
      const data = response.notification.request.content.data as unknown as PushNotificationData;
      handleNotification(data);
    });

    return () => {
      subscription.remove();
      notificationReceivedListener.current?.remove();
      notificationResponseListener.current?.remove();
      stopPeriodicLocationUpdates();
    };
  }, [isLoggedIn, startPeriodicLocationUpdates, stopPeriodicLocationUpdates]);

  if (isLoading) {
    return null;
  }

  return (
    <AuthContext.Provider value={authContext}>
      <NavigationContainer ref={navigationRef}>
        {isLoggedIn ? <MainAppStackScreen /> : <AuthStackScreen />}
      </NavigationContainer>
    </AuthContext.Provider>
  );
}